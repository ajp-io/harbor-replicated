name: PR Tests

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'harbor/**'
      - 'manifests/**'
      - '.github/workflows/pr-test.yml'  # Allow testing the workflow itself

env:
  REPLICATED_APP: harbor-enterprise
  REPLICATED_API_ORIGIN: https://api.replicated.com/vendor

jobs:
  create-release:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      test_version: ${{ steps.version.outputs.test_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
          | grep "browser_download_url.*linux_amd64.tar.gz" \
          | cut -d : -f 2,3 \
          | tr -d \" \
          | wget -O replicated.tar.gz -qi -
          tar xf replicated.tar.gz
          sudo mv replicated /usr/local/bin/

      - name: Generate test version
        id: version
        run: |
          # Generate unique version for PR testing using PR number, run number, and commit SHA
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          VERSION="pr${{ github.event.pull_request.number }}-r${{ github.run_number }}-${COMMIT_SHORT}"
          echo "test_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated unique test version: $VERSION"

      - name: Package Helm chart
        run: |
          # Clean any existing packages
          rm -f manifests/*.tgz

          # Package the chart
          helm package harbor -d manifests -u
          echo "Packaged chart:"
          ls -la manifests/*.tgz

      - name: Create test release
        run: |
          # Create release on Unstable channel for testing
          replicated release create \
            --lint \
            --yaml-dir ./manifests \
            --promote Unstable \
            --version "${{ steps.version.outputs.test_version }}"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ env.REPLICATED_APP }}

      - name: Clean up test artifacts
        if: always()
        run: |
          rm -f manifests/*.tgz
          echo "Cleaned up build artifacts"

  test-embedded-cluster:
    needs: create-release
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
          | grep "browser_download_url.*linux_amd64.tar.gz" \
          | cut -d : -f 2,3 \
          | tr -d \" \
          | wget -O replicated.tar.gz -qi -
          tar xf replicated.tar.gz
          sudo mv replicated /usr/local/bin/

      - name: Create test VM
        id: vm
        run: |
          # Create VM for testing with 10 minute wait and unique name
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          VM_NAME="embedded-cluster-pr${{ github.event.pull_request.number }}-r${{ github.run_number }}-${COMMIT_SHORT}"
          echo "Creating VM for PR testing: $VM_NAME (waiting up to 10 minutes)..."
          VM_OUTPUT=$(replicated vm create \
            --distribution ubuntu \
            --version 22.04 \
            --instance-type r1.small \
            --name "$VM_NAME" \
            --wait 10m \
            --output json)

          echo "VM creation output:"
          echo "$VM_OUTPUT"

          # Try to extract VM ID - handle both object and array responses
          VM_ID=$(echo "$VM_OUTPUT" | jq -r 'if type == "array" then .[0].id else .id end')

          if [[ -z "$VM_ID" || "$VM_ID" == "null" ]]; then
            echo "‚ùå Failed to get VM ID from output"
            exit 1
          fi

          echo "vm_id=$VM_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ VM created and ready: $VM_ID"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ env.REPLICATED_APP }}

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VM_SSH_PRIVATE_KEY }}

      - name: Setup SSH known hosts and transfer files
        run: |
          # Setup SSH known hosts (testing key sync fix)
          mkdir -p ~/.ssh
          ssh-keyscan replicatedvm.com >> ~/.ssh/known_hosts

          # Get SCP endpoint for file transfers
          SCP_ENDPOINT=$(replicated vm scp-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)
          echo "SCP endpoint: $SCP_ENDPOINT"

          # Make scripts executable
          chmod +x scripts/test-embedded-install.sh

          # Transfer test files to VM home directory first
          scp -O -o StrictHostKeyChecking=no test/config-values.yaml $SCP_ENDPOINT/config-values.yaml
          scp -O -o StrictHostKeyChecking=no scripts/test-embedded-install.sh $SCP_ENDPOINT/test.sh

          # Get SSH endpoint and move files to /tmp
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)
          ssh -o StrictHostKeyChecking=no $SSH_ENDPOINT 'sudo mv config-values.yaml /tmp/ && sudo mv test.sh /tmp/ && ls -la /tmp/'

          echo "Files transferred successfully"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Run embedded cluster installation test
        id: test
        run: |
          # Get SSH endpoint for connection (fallback to explicit username until auto-detection works)
          SSH_ENDPOINT=$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)
          echo "SSH endpoint: $SSH_ENDPOINT"

          # Run the test script on the VM with the test version
          echo "Running embedded cluster installation test for version: ${{ needs.create-release.outputs.test_version }}"
          ssh -o StrictHostKeyChecking=no $SSH_ENDPOINT 'chmod +x /tmp/test.sh && sudo TEST_VERSION="${{ needs.create-release.outputs.test_version }}" LICENSE_ID="${{ secrets.HARBOR_LICENSE_ID }}" /tmp/test.sh'

          echo "Test completed successfully!"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Cleanup VM
        if: success()
        run: |
          if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
            echo "‚úÖ Test passed! Cleaning up VM: ${{ steps.vm.outputs.vm_id }}"
            replicated vm rm ${{ steps.vm.outputs.vm_id }} || true
            echo "VM cleanup completed"
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Report test results
        if: always()
        run: |
          TEST_OUTCOME="${{ steps.test.outcome }}"

          if [[ "$TEST_OUTCOME" == "success" ]]; then
            echo "‚úÖ Embedded cluster installation test PASSED"
            echo "The changes in this PR work correctly with embedded cluster deployment."
          elif [[ "$TEST_OUTCOME" == "failure" ]]; then
            echo "‚ùå Embedded cluster installation test FAILED"
            echo "There may be issues with the changes in this PR. Please review the logs above."

            # Show VM info for debugging
            if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
              echo ""
              echo "üîç Debug Information:"
              echo "VM ID: ${{ steps.vm.outputs.vm_id }}"
              echo "VM has been left running for debugging (1h TTL)"
              echo "You can SSH to it using: ssh \$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)"
            fi
            exit 1
          elif [[ "$TEST_OUTCOME" == "skipped" || -z "$TEST_OUTCOME" ]]; then
            echo "‚ùå Embedded cluster installation test was SKIPPED due to earlier failures"
            echo "Please check the logs above to see what step failed."

            # Show VM info for debugging if VM was created
            if [[ -n "${{ steps.vm.outputs.vm_id }}" ]]; then
              echo ""
              echo "üîç Debug Information:"
              echo "VM ID: ${{ steps.vm.outputs.vm_id }}"
              echo "VM has been left running for debugging (1h TTL)"
              echo "You can SSH to it using: ssh \$(replicated vm ssh-endpoint ${{ steps.vm.outputs.vm_id }} --username ajp-io)"
            fi
            exit 1
          else
            echo "‚ùå Embedded cluster installation test had unexpected outcome: $TEST_OUTCOME"
            exit 1
          fi

  test-kots:
    needs: create-release
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
          | grep "browser_download_url.*linux_amd64.tar.gz" \
          | cut -d : -f 2,3 \
          | tr -d \" \
          | wget -O replicated.tar.gz -qi -
          tar xf replicated.tar.gz
          sudo mv replicated /usr/local/bin/

      - name: Create K3S cluster
        id: cluster
        run: |
          # Create K3S cluster for KOTS testing
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          CLUSTER_NAME="kots-pr${{ github.event.pull_request.number }}-r${{ github.run_number }}-${COMMIT_SHORT}"
          echo "Creating K3S cluster for KOTS testing: $CLUSTER_NAME (waiting up to 10 minutes)..."

          CLUSTER_OUTPUT=$(replicated cluster create \
            --distribution k3s \
            --version 1.33.4 \
            --instance-type r1.small \
            --name "$CLUSTER_NAME" \
            --wait 10m \
            --output json)

          echo "Cluster creation output:"
          echo "$CLUSTER_OUTPUT"

          # Extract cluster ID from output
          CLUSTER_ID=$(echo "$CLUSTER_OUTPUT" | jq -r '.id // empty')

          if [[ -z "$CLUSTER_ID" || "$CLUSTER_ID" == "null" ]]; then
            echo "‚ùå Failed to get cluster ID from output"
            exit 1
          fi

          echo "cluster_id=$CLUSTER_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ K3S cluster created and ready: $CLUSTER_ID"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Setup kubectl and run KOTS install
        run: |
          # Set up kubectl using replicated cluster kubeconfig
          echo "Setting up kubectl with cluster kubeconfig..."
          echo "Cluster ID: ${{ steps.cluster.outputs.cluster_id }}"

          # The replicated cluster kubeconfig command updates ~/.kube/config automatically
          # and sets the current context, so we don't need to manage a separate kubeconfig file
          replicated cluster kubeconfig ${{ steps.cluster.outputs.cluster_id }}

          # Verify kubectl access (should now use the updated ~/.kube/config)
          echo "Verifying kubectl access..."
          kubectl get nodes
          kubectl get namespaces

          # Make script executable and transfer config
          chmod +x scripts/test-kots-install.sh
          cp test/config-values.yaml /tmp/config-values.yaml

          # Run KOTS installation test
          echo "Running KOTS installation test for version: ${{ needs.create-release.outputs.test_version }}"
          TEST_VERSION="${{ needs.create-release.outputs.test_version }}" \
          REPLICATED_API_TOKEN="${{ secrets.REPLICATED_API_TOKEN }}" \
          ./scripts/test-kots-install.sh

          echo "KOTS test completed successfully!"
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Cleanup K3S cluster
        if: success()
        run: |
          if [[ -n "${{ steps.cluster.outputs.cluster_id }}" ]]; then
            echo "‚úÖ Test passed! Cleaning up K3S cluster: ${{ steps.cluster.outputs.cluster_id }}"
            replicated cluster rm ${{ steps.cluster.outputs.cluster_id }} || true
            echo "Cluster cleanup completed"
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}

      - name: Report test results
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "‚úÖ KOTS installation test PASSED"
            echo "The changes in this PR work correctly with KOTS deployment."
          else
            echo "‚ùå KOTS installation test FAILED"
            echo "There may be issues with the changes in this PR. Please review the logs above."

            # Show cluster info for debugging
            if [[ -n "${{ steps.cluster.outputs.cluster_id }}" ]]; then
              echo ""
              echo "üîç Debug Information:"
              echo "Cluster ID: ${{ steps.cluster.outputs.cluster_id }}"
              echo "Cluster has been left running for debugging (1h TTL)"
              echo "You can access it using: replicated cluster kubeconfig ${{ steps.cluster.outputs.cluster_id }}"
            fi
            exit 1
          fi